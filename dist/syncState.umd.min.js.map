{"version":3,"sources":["webpack:///webpack/universalModuleDefinition","webpack:///syncState.umd.min.js","webpack:///webpack/bootstrap a5d96e30fa2982463e10","webpack:///./~/broadcast-channel/dist/es/util.js","webpack:///./~/detect-node/browser.js","webpack:///./~/broadcast-channel/dist/es/options.js","webpack:///./~/broadcast-channel/dist/es/oblivious-set.js","webpack:///./~/broadcast-channel/dist/es/index.js","webpack:///./src/syncState.js","webpack:///./~/broadcast-channel/dist/es/method-chooser.js","webpack:///./~/broadcast-channel/dist/es/methods/indexed-db.js","webpack:///./~/broadcast-channel/dist/es/methods/localstorage.js","webpack:///./~/broadcast-channel/dist/es/methods/native.js"],"names":["root","factory","exports","module","define","amd","this","modules","__webpack_require__","moduleId","installedModules","i","l","call","m","c","value","d","name","getter","o","Object","defineProperty","configurable","enumerable","get","n","__esModule","object","property","prototype","hasOwnProperty","p","s","__webpack_exports__","isPromise","obj","then","sleep","time","Promise","res","setTimeout","randomInt","min","max","Math","floor","random","randomToken","length","text","possible","charAt","microSeconds","ms","Date","getTime","lastMs","additional","fillOptionsWithDefaults","options","JSON","parse","stringify","webWorkerSupport","idb","ttl","fallbackInterval","localstorage","removeTimeout","node","useFastPath","_removeTooOldValues","obliviousSet","olderThen","now","iterator","set","Symbol","next","timeMap","ObliviousSet","Set","Map","has","bind","add","clear","_post","broadcastChannel","type","msg","method","msgObj","data","_prepP","resolve","postMessage","_state","_prepareChannel","channel","maybePromise","create","__WEBPACK_IMPORTED_MODULE_0__util_js__","_hasMessageListeners","_addEL","message","internal","_addListenerObject","push","_startListening","_removeListenerObject","filter","_stopListening","_iL","listenerFn","forEach","fn","onMessage","__WEBPACK_IMPORTED_MODULE_1__method_chooser_js__","__WEBPACK_IMPORTED_MODULE_2__options_js__","BroadcastChannel","_onML","_befC","_pubkey","clearNodeFolder","closed","Error","postInternal","onmessage","listenObj","addEventListener","removeEventListener","find","close","_this","awaitPrepare","all","map","s4","toString","substring","guid","generateUuidForAction","action","stampedAction","$uuid","$wuid","WINDOW_STATE_SYNC_ID","isActionAllowed","_ref","predicate","blacklist","whitelist","allowed","Array","isArray","indexOf","isActionSynced","$isSync","createMessageListener","_ref2","dispatch","isSynced","tabs","RECEIVE_INIT_STATE","lastUuid","GET_INIT_STATE","SEND_INIT_STATE","receiveIniteState","payload","assign","sendIniteState","initStateWithPrevTab","withReduxStateSync","createReduxStateSync","createStateSyncMiddleware","undefined","_broadcastChannel","_broadcastChannel2","default","defaultConfig","broadcastChannelOption","prepareState","state","getIniteState","isMessageListenerCreated","config","arguments","_ref3","getState","e","console","error","_ref4","appReducer","initState","_ref5","chooseMethod","ret","METHODS","chooseMethods","__WEBPACK_IMPORTED_MODULE_0_detect_node___default","a","useMethod","canBeUsed","__WEBPACK_IMPORTED_MODULE_0_detect_node__","__WEBPACK_IMPORTED_MODULE_1__methods_native_js__","__WEBPACK_IMPORTED_MODULE_2__methods_indexed_db_js__","__WEBPACK_IMPORTED_MODULE_3__methods_localstorage_js__","NodeMethod","getIdb","indexedDB","window","mozIndexedDB","webkitIndexedDB","msIndexedDB","createDatabase","channelName","IndexedDB","dbName","DB_PREFIX","openRequest","open","onupgradeneeded","ev","target","result","createObjectStore","OBJECT_STORE_ID","keyPath","autoIncrement","rej","onerror","onsuccess","writeMessage","db","readerUuid","messageJson","writeObject","uuid","transaction","oncomplete","objectStore","getMessagesHigherThen","lastCursorId","keyRangeValue","IDBKeyRange","bound","Infinity","openCursor","cursor","removeMessageById","id","request","getOldMessages","msgObk","cleanOldMessages","tooOld","__WEBPACK_IMPORTED_MODULE_3__options__","__WEBPACK_IMPORTED_MODULE_1__util_js__","eMIs","__WEBPACK_IMPORTED_MODULE_2__oblivious_set__","writeBlockPromise","messagesCallback","readQueuePromises","_readLoop","readNewMessages","_filterMessage","messagesCallbackTime","newerMessages","sort","msgObjA","msgObjB","channelState","averageResponseTime","getLocalStorage","localStorage","storageKey","KEY_PREFIX","__WEBPACK_IMPORTED_MODULE_3__util__","key","writeObj","token","setItem","document","createEvent","initEvent","newValue","dispatchEvent","addStorageEventListener","listener","removeStorageEventListener","__WEBPACK_IMPORTED_MODULE_2__options__","__WEBPACK_IMPORTED_MODULE_1__oblivious_set__","bc","subFns","__WEBPACK_IMPORTED_MODULE_1__util__"],"mappings":"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","file":"syncState.umd.min.js","sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"reduxStateSync\"] = factory();\n\telse\n\t\troot[\"reduxStateSync\"] = factory();\n})(this, function() {\nreturn \n\n\n// WEBPACK FOOTER //\n// webpack/universalModuleDefinition","(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"reduxStateSync\"] = factory();\n\telse\n\t\troot[\"reduxStateSync\"] = factory();\n})(this, function() {\nreturn /******/ (function(modules) { // webpackBootstrap\n/******/ \t// The module cache\n/******/ \tvar installedModules = {};\n/******/\n/******/ \t// The require function\n/******/ \tfunction __webpack_require__(moduleId) {\n/******/\n/******/ \t\t// Check if module is in cache\n/******/ \t\tif(installedModules[moduleId]) {\n/******/ \t\t\treturn installedModules[moduleId].exports;\n/******/ \t\t}\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = installedModules[moduleId] = {\n/******/ \t\t\ti: moduleId,\n/******/ \t\t\tl: false,\n/******/ \t\t\texports: {}\n/******/ \t\t};\n/******/\n/******/ \t\t// Execute the module function\n/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n/******/\n/******/ \t\t// Flag the module as loaded\n/******/ \t\tmodule.l = true;\n/******/\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n/******/\n/******/\n/******/ \t// expose the modules object (__webpack_modules__)\n/******/ \t__webpack_require__.m = modules;\n/******/\n/******/ \t// expose the module cache\n/******/ \t__webpack_require__.c = installedModules;\n/******/\n/******/ \t// identity function for calling harmony imports with the correct context\n/******/ \t__webpack_require__.i = function(value) { return value; };\n/******/\n/******/ \t// define getter function for harmony exports\n/******/ \t__webpack_require__.d = function(exports, name, getter) {\n/******/ \t\tif(!__webpack_require__.o(exports, name)) {\n/******/ \t\t\tObject.defineProperty(exports, name, {\n/******/ \t\t\t\tconfigurable: false,\n/******/ \t\t\t\tenumerable: true,\n/******/ \t\t\t\tget: getter\n/******/ \t\t\t});\n/******/ \t\t}\n/******/ \t};\n/******/\n/******/ \t// getDefaultExport function for compatibility with non-harmony modules\n/******/ \t__webpack_require__.n = function(module) {\n/******/ \t\tvar getter = module && module.__esModule ?\n/******/ \t\t\tfunction getDefault() { return module['default']; } :\n/******/ \t\t\tfunction getModuleExports() { return module; };\n/******/ \t\t__webpack_require__.d(getter, 'a', getter);\n/******/ \t\treturn getter;\n/******/ \t};\n/******/\n/******/ \t// Object.prototype.hasOwnProperty.call\n/******/ \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n/******/\n/******/ \t// __webpack_public_path__\n/******/ \t__webpack_require__.p = \"\";\n/******/\n/******/ \t// Load entry module and return exports\n/******/ \treturn __webpack_require__(__webpack_require__.s = 5);\n/******/ })\n/************************************************************************/\n/******/ ([\n/* 0 */\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\n/* harmony export (immutable) */ __webpack_exports__[\"a\"] = isPromise;\n/* harmony export (immutable) */ __webpack_exports__[\"c\"] = sleep;\n/* harmony export (immutable) */ __webpack_exports__[\"e\"] = randomInt;\n/* harmony export (immutable) */ __webpack_exports__[\"d\"] = randomToken;\n/* harmony export (immutable) */ __webpack_exports__[\"b\"] = microSeconds;\n/**\n * returns true if the given object is a promise\n */\nfunction isPromise(obj) {\n  if (obj && typeof obj.then === 'function') {\n    return true;\n  } else {\n    return false;\n  }\n}\nfunction sleep(time) {\n  if (!time) time = 0;\n  return new Promise(function (res) {\n    return setTimeout(res, time);\n  });\n}\nfunction randomInt(min, max) {\n  return Math.floor(Math.random() * (max - min + 1) + min);\n}\n/**\n * https://stackoverflow.com/a/1349426/3443137\n */\n\nfunction randomToken(length) {\n  if (!length) length = 5;\n  var text = '';\n  var possible = 'abcdefghijklmnopqrstuvwxzy0123456789';\n\n  for (var i = 0; i < length; i++) {\n    text += possible.charAt(Math.floor(Math.random() * possible.length));\n  }\n\n  return text;\n}\nvar lastMs = 0;\nvar additional = 0;\n/**\n * returns the current time in micro-seconds,\n * WARNING: This is a pseudo-function\n * Performance.now is not reliable in webworkers, so we just make sure to never return the same time.\n * This is enough in browsers, and this function will not be used in nodejs.\n * The main reason for this hack is to ensure that BroadcastChannel behaves equal to production when it is used in fast-running unit tests.\n */\n\nfunction microSeconds() {\n  var ms = new Date().getTime();\n\n  if (ms === lastMs) {\n    additional++;\n    return ms * 1000 + additional;\n  } else {\n    lastMs = ms;\n    additional = 0;\n    return ms * 1000;\n  }\n}\n\n/***/ }),\n/* 1 */\n/***/ (function(module, exports) {\n\nmodule.exports = false;\n\n\n\n/***/ }),\n/* 2 */\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\n/* harmony export (immutable) */ __webpack_exports__[\"a\"] = fillOptionsWithDefaults;\nfunction fillOptionsWithDefaults(options) {\n  if (!options) options = {};\n  options = JSON.parse(JSON.stringify(options)); // main\n\n  if (typeof options.webWorkerSupport === 'undefined') options.webWorkerSupport = true; // indexed-db\n\n  if (!options.idb) options.idb = {}; //  after this time the messages get deleted\n\n  if (!options.idb.ttl) options.idb.ttl = 1000 * 45;\n  if (!options.idb.fallbackInterval) options.idb.fallbackInterval = 150; // localstorage\n\n  if (!options.localstorage) options.localstorage = {};\n  if (!options.localstorage.removeTimeout) options.localstorage.removeTimeout = 1000 * 60; // node\n\n  if (!options.node) options.node = {};\n  if (!options.node.ttl) options.node.ttl = 1000 * 60 * 2; // 2 minutes;\n\n  if (typeof options.node.useFastPath === 'undefined') options.node.useFastPath = true;\n  return options;\n}\n\n/***/ }),\n/* 3 */\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\n/* unused harmony export _removeTooOldValues */\n/**\n *\n *\n */\nvar ObliviousSet = function ObliviousSet(ttl) {\n  this.ttl = ttl;\n  this.set = new Set();\n  this.timeMap = new Map();\n  this.has = this.set.has.bind(this.set);\n};\n\nObliviousSet.prototype = {\n  add: function add(value) {\n    this.timeMap.set(value, now());\n    this.set.add(value);\n\n    _removeTooOldValues(this);\n  },\n  clear: function clear() {\n    this.set.clear();\n    this.timeMap.clear();\n  }\n};\nfunction _removeTooOldValues(obliviousSet) {\n  var olderThen = now() - obliviousSet.ttl;\n  var iterator = obliviousSet.set[Symbol.iterator]();\n\n  while (true) {\n    var value = iterator.next().value;\n    if (!value) return; // no more elements\n\n    var time = obliviousSet.timeMap.get(value);\n\n    if (time < olderThen) {\n      obliviousSet.timeMap[\"delete\"](value);\n      obliviousSet.set[\"delete\"](value);\n    } else {\n      // we reached a value that is not old enough\n      return;\n    }\n  }\n}\n\nfunction now() {\n  return new Date().getTime();\n}\n\n/* harmony default export */ __webpack_exports__[\"a\"] = (ObliviousSet);\n\n/***/ }),\n/* 4 */\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\nObject.defineProperty(__webpack_exports__, \"__esModule\", { value: true });\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__util_js__ = __webpack_require__(0);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__method_chooser_js__ = __webpack_require__(6);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__options_js__ = __webpack_require__(2);\n\n\n\n\nvar BroadcastChannel = function BroadcastChannel(name, options) {\n  this.name = name;\n  this.options = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_2__options_js__[\"a\" /* fillOptionsWithDefaults */])(options);\n  this.method = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_1__method_chooser_js__[\"a\" /* chooseMethod */])(this.options); // isListening\n\n  this._iL = false;\n  /**\n   * _onMessageListener\n   * setting onmessage twice,\n   * will overwrite the first listener\n   */\n\n  this._onML = null;\n  /**\n   * _addEventListeners\n   */\n\n  this._addEL = {\n    message: [],\n    internal: []\n  };\n  /**\n   * _beforeClose\n   * array of promises that will be awaited\n   * before the channel is closed\n   */\n\n  this._befC = [];\n  /**\n   * _preparePromise\n   */\n\n  this._prepP = null;\n\n  _prepareChannel(this);\n}; // STATICS\n\n/**\n * used to identify if someone overwrites\n * window.BroadcastChannel with this\n * See methods/native.js\n */\n\n\nBroadcastChannel._pubkey = true;\n/**\n * clears the tmp-folder if is node\n * @return {Promise<boolean>} true if has run, false if not node\n */\n\nBroadcastChannel.clearNodeFolder = function (options) {\n  options = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_2__options_js__[\"a\" /* fillOptionsWithDefaults */])(options);\n  var method = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_1__method_chooser_js__[\"a\" /* chooseMethod */])(options);\n\n  if (method.type === 'node') {\n    return method.clearNodeFolder().then(function () {\n      return true;\n    });\n  } else {\n    return Promise.resolve(false);\n  }\n}; // PROTOTYPE\n\n\nBroadcastChannel.prototype = {\n  postMessage: function postMessage(msg) {\n    if (this.closed) {\n      throw new Error('BroadcastChannel.postMessage(): ' + 'Cannot post message after channel has closed');\n    }\n\n    return _post(this, 'message', msg);\n  },\n  postInternal: function postInternal(msg) {\n    return _post(this, 'internal', msg);\n  },\n\n  set onmessage(fn) {\n    var time = this.method.microSeconds();\n    var listenObj = {\n      time: time,\n      fn: fn\n    };\n\n    _removeListenerObject(this, 'message', this._onML);\n\n    if (fn && typeof fn === 'function') {\n      this._onML = listenObj;\n\n      _addListenerObject(this, 'message', listenObj);\n    } else {\n      this._onML = null;\n    }\n  },\n\n  addEventListener: function addEventListener(type, fn) {\n    var time = this.method.microSeconds();\n    var listenObj = {\n      time: time,\n      fn: fn\n    };\n\n    _addListenerObject(this, type, listenObj);\n  },\n  removeEventListener: function removeEventListener(type, fn) {\n    var obj = this._addEL[type].find(function (obj) {\n      return obj.fn === fn;\n    });\n\n    _removeListenerObject(this, type, obj);\n  },\n  close: function close() {\n    var _this = this;\n\n    if (this.closed) return;\n    this.closed = true;\n    var awaitPrepare = this._prepP ? this._prepP : Promise.resolve();\n    this._onML = null;\n    this._addEL.message = [];\n    return awaitPrepare.then(function () {\n      return Promise.all(_this._befC.map(function (fn) {\n        return fn();\n      }));\n    }).then(function () {\n      return _this.method.close(_this._state);\n    });\n  },\n\n  get type() {\n    return this.method.type;\n  }\n\n};\n\nfunction _post(broadcastChannel, type, msg) {\n  var time = broadcastChannel.method.microSeconds();\n  var msgObj = {\n    time: time,\n    type: type,\n    data: msg\n  };\n  var awaitPrepare = broadcastChannel._prepP ? broadcastChannel._prepP : Promise.resolve();\n  return awaitPrepare.then(function () {\n    return broadcastChannel.method.postMessage(broadcastChannel._state, msgObj);\n  });\n}\n\nfunction _prepareChannel(channel) {\n  var maybePromise = channel.method.create(channel.name, channel.options);\n\n  if (__webpack_require__.i(__WEBPACK_IMPORTED_MODULE_0__util_js__[\"a\" /* isPromise */])(maybePromise)) {\n    channel._prepP = maybePromise;\n    maybePromise.then(function (s) {\n      // used in tests to simulate slow runtime\n\n      /*if (channel.options.prepareDelay) {\n           await new Promise(res => setTimeout(res, this.options.prepareDelay));\n      }*/\n      channel._state = s;\n    });\n  } else {\n    channel._state = maybePromise;\n  }\n}\n\nfunction _hasMessageListeners(channel) {\n  if (channel._addEL.message.length > 0) return true;\n  if (channel._addEL.internal.length > 0) return true;\n  return false;\n}\n\nfunction _addListenerObject(channel, type, obj) {\n  channel._addEL[type].push(obj);\n\n  _startListening(channel);\n}\n\nfunction _removeListenerObject(channel, type, obj) {\n  channel._addEL[type] = channel._addEL[type].filter(function (o) {\n    return o !== obj;\n  });\n\n  _stopListening(channel);\n}\n\nfunction _startListening(channel) {\n  if (!channel._iL && _hasMessageListeners(channel)) {\n    // someone is listening, start subscribing\n    var listenerFn = function listenerFn(msgObj) {\n      channel._addEL[msgObj.type].forEach(function (obj) {\n        if (msgObj.time >= obj.time) {\n          obj.fn(msgObj.data);\n        }\n      });\n    };\n\n    var time = channel.method.microSeconds();\n\n    if (channel._prepP) {\n      channel._prepP.then(function () {\n        channel._iL = true;\n        channel.method.onMessage(channel._state, listenerFn, time);\n      });\n    } else {\n      channel._iL = true;\n      channel.method.onMessage(channel._state, listenerFn, time);\n    }\n  }\n}\n\nfunction _stopListening(channel) {\n  if (channel._iL && !_hasMessageListeners(channel)) {\n    // noone is listening, stop subscribing\n    channel._iL = false;\n    var time = channel.method.microSeconds();\n    channel.method.onMessage(channel._state, null, time);\n  }\n}\n\n/* harmony default export */ __webpack_exports__[\"default\"] = (BroadcastChannel);\n\n/***/ }),\n/* 5 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.initStateWithPrevTab = exports.withReduxStateSync = exports.createReduxStateSync = exports.createStateSyncMiddleware = undefined;\nexports.generateUuidForAction = generateUuidForAction;\nexports.isActionAllowed = isActionAllowed;\nexports.isActionSynced = isActionSynced;\nexports.createMessageListener = createMessageListener;\n\nvar _broadcastChannel = __webpack_require__(4);\n\nvar _broadcastChannel2 = _interopRequireDefault(_broadcastChannel);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nvar lastUuid = 0; /* eslint-env browser */\n\nvar GET_INIT_STATE = '&_GET_INIT_STATE';\nvar SEND_INIT_STATE = '&_SEND_INIT_STATE';\nvar RECEIVE_INIT_STATE = '&_RECEIVE_INIT_STATE';\n\nvar defaultConfig = {\n  channel: 'redux_state_sync',\n  predicate: null,\n  blacklist: [],\n  whitelist: [],\n  broadcastChannelOption: null,\n  prepareState: function prepareState(state) {\n    return state;\n  }\n};\n\nvar getIniteState = function getIniteState() {\n  return { type: GET_INIT_STATE };\n};\nvar sendIniteState = function sendIniteState() {\n  return { type: SEND_INIT_STATE };\n};\nvar receiveIniteState = function receiveIniteState(state) {\n  return { type: RECEIVE_INIT_STATE, payload: state };\n};\n\nfunction s4() {\n  return Math.floor((1 + Math.random()) * 0x10000).toString(16).substring(1);\n}\n\nfunction guid() {\n  return '' + s4() + s4() + '-' + s4() + '-' + s4() + '-' + s4() + '-' + s4() + s4() + s4();\n}\n\n// generate current window unique id\nvar WINDOW_STATE_SYNC_ID = guid();\n// if the message receiver is already created\nvar isMessageListenerCreated = false;\n// export for test\nfunction generateUuidForAction(action) {\n  var stampedAction = action;\n  stampedAction.$uuid = guid();\n  stampedAction.$wuid = WINDOW_STATE_SYNC_ID;\n  return stampedAction;\n}\n// export for test\nfunction isActionAllowed(_ref) {\n  var predicate = _ref.predicate,\n      blacklist = _ref.blacklist,\n      whitelist = _ref.whitelist;\n\n  var allowed = function allowed() {\n    return true;\n  };\n\n  if (predicate && typeof predicate === 'function') {\n    allowed = predicate;\n  } else if (Array.isArray(blacklist)) {\n    allowed = function allowed(type) {\n      return blacklist.indexOf(type) < 0;\n    };\n  } else if (Array.isArray(whitelist)) {\n    allowed = function allowed(type) {\n      return whitelist.indexOf(type) >= 0;\n    };\n  }\n  return allowed;\n}\n// export for test\nfunction isActionSynced(action) {\n  return !!action.$isSync;\n}\n// export for test\nfunction createMessageListener(_ref2) {\n  var channel = _ref2.channel,\n      dispatch = _ref2.dispatch,\n      allowed = _ref2.allowed;\n\n  var isSynced = false;\n  var tabs = {};\n  var messageChannel = channel;\n  messageChannel.onmessage = function (stampedAction) {\n    // Ignore if this action is triggered by this window\n    if (stampedAction.$wuid === WINDOW_STATE_SYNC_ID) {\n      return;\n    }\n    // IE bug https://stackoverflow.com/questions/18265556/why-does-internet-explorer-fire-the-window-storage-event-on-the-window-that-st\n    if (stampedAction.type === RECEIVE_INIT_STATE) {\n      return;\n    }\n    // ignore other values that saved to localstorage.\n    if (stampedAction.$uuid && stampedAction.$uuid !== lastUuid) {\n      if (stampedAction.type === GET_INIT_STATE && !tabs[stampedAction.$wuid]) {\n        tabs[stampedAction.$wuid] = true;\n        dispatch(sendIniteState());\n      } else if (stampedAction.type === SEND_INIT_STATE && !tabs[stampedAction.$wuid]) {\n        if (!isSynced) {\n          isSynced = true;\n          dispatch(receiveIniteState(stampedAction.payload));\n        }\n        return;\n      } else if (allowed(stampedAction.type)) {\n        lastUuid = stampedAction.$uuid;\n        dispatch(Object.assign(stampedAction, {\n          $isSync: true\n        }));\n      }\n    }\n  };\n}\n\nvar createStateSyncMiddleware = exports.createStateSyncMiddleware = function createStateSyncMiddleware() {\n  var config = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : defaultConfig;\n\n  var allowed = isActionAllowed(config);\n  var channel = new _broadcastChannel2.default(config.channel, config.broadcastChannelOption);\n  var prepareState = config.prepareState || defaultConfig.prepareState;\n\n  return function (_ref3) {\n    var getState = _ref3.getState,\n        dispatch = _ref3.dispatch;\n    return function (next) {\n      return function (action) {\n        // create message receiver\n        if (!isMessageListenerCreated) {\n          isMessageListenerCreated = true;\n          createMessageListener({ channel: channel, dispatch: dispatch, allowed: allowed });\n        }\n        // post messages\n        if (action && !action.$uuid) {\n          var stampedAction = generateUuidForAction(action);\n          lastUuid = stampedAction.$uuid;\n          try {\n            if (action.type === SEND_INIT_STATE) {\n              if (getState()) {\n                stampedAction.payload = prepareState(getState());\n                channel.postMessage(stampedAction);\n              }\n              return next(action);\n            }\n            if (allowed(stampedAction.type) || action.type === GET_INIT_STATE) {\n              channel.postMessage(stampedAction);\n            }\n          } catch (e) {\n            console.error(\"Your browser doesn't support cross tab communication\");\n          }\n        }\n        return next(Object.assign(action, {\n          $isSync: typeof action.$isSync === 'undefined' ? false : action.$isSync\n        }));\n      };\n    };\n  };\n};\n\nvar createReduxStateSync = exports.createReduxStateSync = function createReduxStateSync(_ref4) {\n  var prepareState = _ref4.prepareState;\n  return function (appReducer) {\n    return function (state, action) {\n      var initState = state;\n      if (action.type === RECEIVE_INIT_STATE) {\n        initState = prepareState(action.payload);\n      }\n      return appReducer(initState, action);\n    };\n  };\n};\n\n// init state with other tab's state\nvar withReduxStateSync = exports.withReduxStateSync = createReduxStateSync({\n  prepareState: function prepareState(state) {\n    return state;\n  }\n});\n\nvar initStateWithPrevTab = exports.initStateWithPrevTab = function initStateWithPrevTab(_ref5) {\n  var dispatch = _ref5.dispatch;\n\n  dispatch(getIniteState());\n};\n\n/***/ }),\n/* 6 */\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\n/* harmony export (immutable) */ __webpack_exports__[\"a\"] = chooseMethod;\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_detect_node__ = __webpack_require__(1);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_detect_node___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0_detect_node__);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__methods_native_js__ = __webpack_require__(9);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__methods_indexed_db_js__ = __webpack_require__(7);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__methods_localstorage_js__ = __webpack_require__(8);\nvar require;\n\n\n // order is important\n\nvar METHODS = [__WEBPACK_IMPORTED_MODULE_1__methods_native_js__[\"a\" /* default */], // fastest\n__WEBPACK_IMPORTED_MODULE_2__methods_indexed_db_js__[\"a\" /* default */], __WEBPACK_IMPORTED_MODULE_3__methods_localstorage_js__[\"a\" /* default */]];\nvar REQUIRE_FUN = require;\n/**\n * The NodeMethod is loaded lazy\n * so it will not get bundled in browser-builds\n */\n\nif (__WEBPACK_IMPORTED_MODULE_0_detect_node___default.a) {\n  /**\n   * we use the non-transpiled code for nodejs\n   * because it runs faster\n   */\n  var NodeMethod = __webpack_require__(10);\n  /**\n   * this will be false for webpackbuilds\n   * which will shim the node-method with an empty object {}\n   */\n\n  if (typeof NodeMethod.canBeUsed === 'function') {\n    METHODS.push(NodeMethod);\n  }\n}\n\nfunction chooseMethod(options) {\n  // directly chosen\n  if (options.type) {\n    var ret = METHODS.find(function (m) {\n      return m.type === options.type;\n    });\n    if (!ret) throw new Error('method-type ' + options.type + ' not found');else return ret;\n  }\n\n  var chooseMethods = METHODS;\n\n  if (!options.webWorkerSupport && !__WEBPACK_IMPORTED_MODULE_0_detect_node___default.a) {\n    // prefer localstorage over idb when no webworker-support needed\n    chooseMethods = METHODS.filter(function (m) {\n      return m.type !== 'idb';\n    });\n  }\n\n  var useMethod = chooseMethods.find(function (method) {\n    return method.canBeUsed();\n  });\n  if (!useMethod) throw new Error('No useable methode found:' + JSON.stringify(METHODS.map(function (m) {\n    return m.type;\n  })));else return useMethod;\n}\n\n/***/ }),\n/* 7 */\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\n/* unused harmony export microSeconds */\n/* unused harmony export type */\n/* unused harmony export getIdb */\n/* unused harmony export createDatabase */\n/* unused harmony export writeMessage */\n/* unused harmony export getAllMessages */\n/* unused harmony export getMessagesHigherThen */\n/* unused harmony export removeMessageById */\n/* unused harmony export getOldMessages */\n/* unused harmony export cleanOldMessages */\n/* unused harmony export create */\n/* unused harmony export close */\n/* unused harmony export postMessage */\n/* unused harmony export onMessage */\n/* unused harmony export canBeUsed */\n/* unused harmony export averageResponseTime */\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_detect_node__ = __webpack_require__(1);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_detect_node___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0_detect_node__);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__util_js__ = __webpack_require__(0);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__oblivious_set__ = __webpack_require__(3);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__options__ = __webpack_require__(2);\n/**\n * this method uses indexeddb to store the messages\n * There is currently no observerAPI for idb\n * @link https://github.com/w3c/IndexedDB/issues/51\n */\n\n\nvar microSeconds = __WEBPACK_IMPORTED_MODULE_1__util_js__[\"b\" /* microSeconds */];\n\n\nvar DB_PREFIX = 'pubkey.broadcast-channel-0-';\nvar OBJECT_STORE_ID = 'messages';\nvar type = 'idb';\nfunction getIdb() {\n  if (typeof indexedDB !== 'undefined') return indexedDB;\n  if (typeof window.mozIndexedDB !== 'undefined') return window.mozIndexedDB;\n  if (typeof window.webkitIndexedDB !== 'undefined') return window.webkitIndexedDB;\n  if (typeof window.msIndexedDB !== 'undefined') return window.msIndexedDB;\n  return false;\n}\nfunction createDatabase(channelName) {\n  var IndexedDB = getIdb(); // create table\n\n  var dbName = DB_PREFIX + channelName;\n  var openRequest = IndexedDB.open(dbName, 1);\n\n  openRequest.onupgradeneeded = function (ev) {\n    var db = ev.target.result;\n    db.createObjectStore(OBJECT_STORE_ID, {\n      keyPath: 'id',\n      autoIncrement: true\n    });\n  };\n\n  var dbPromise = new Promise(function (res, rej) {\n    openRequest.onerror = function (ev) {\n      return rej(ev);\n    };\n\n    openRequest.onsuccess = function () {\n      res(openRequest.result);\n    };\n  });\n  return dbPromise;\n}\n/**\n * writes the new message to the database\n * so other readers can find it\n */\n\nfunction writeMessage(db, readerUuid, messageJson) {\n  var time = new Date().getTime();\n  var writeObject = {\n    uuid: readerUuid,\n    time: time,\n    data: messageJson\n  };\n  var transaction = db.transaction([OBJECT_STORE_ID], 'readwrite');\n  return new Promise(function (res, rej) {\n    transaction.oncomplete = function () {\n      return res();\n    };\n\n    transaction.onerror = function (ev) {\n      return rej(ev);\n    };\n\n    var objectStore = transaction.objectStore(OBJECT_STORE_ID);\n    objectStore.add(writeObject);\n  });\n}\nfunction getAllMessages(db) {\n  var objectStore = db.transaction(OBJECT_STORE_ID).objectStore(OBJECT_STORE_ID);\n  var ret = [];\n  return new Promise(function (res) {\n    objectStore.openCursor().onsuccess = function (ev) {\n      var cursor = ev.target.result;\n\n      if (cursor) {\n        ret.push(cursor.value); //alert(\"Name for SSN \" + cursor.key + \" is \" + cursor.value.name);\n\n        cursor[\"continue\"]();\n      } else {\n        res(ret);\n      }\n    };\n  });\n}\nfunction getMessagesHigherThen(db, lastCursorId) {\n  var objectStore = db.transaction(OBJECT_STORE_ID).objectStore(OBJECT_STORE_ID);\n  var ret = [];\n  var keyRangeValue = IDBKeyRange.bound(lastCursorId + 1, Infinity);\n  return new Promise(function (res) {\n    objectStore.openCursor(keyRangeValue).onsuccess = function (ev) {\n      var cursor = ev.target.result;\n\n      if (cursor) {\n        ret.push(cursor.value); //alert(\"Name for SSN \" + cursor.key + \" is \" + cursor.value.name);\n\n        cursor[\"continue\"]();\n      } else {\n        res(ret);\n      }\n    };\n  });\n}\nfunction removeMessageById(db, id) {\n  var request = db.transaction([OBJECT_STORE_ID], 'readwrite').objectStore(OBJECT_STORE_ID)[\"delete\"](id);\n  return new Promise(function (res) {\n    request.onsuccess = function () {\n      return res();\n    };\n  });\n}\nfunction getOldMessages(db, ttl) {\n  var olderThen = new Date().getTime() - ttl;\n  var objectStore = db.transaction(OBJECT_STORE_ID).objectStore(OBJECT_STORE_ID);\n  var ret = [];\n  return new Promise(function (res) {\n    objectStore.openCursor().onsuccess = function (ev) {\n      var cursor = ev.target.result;\n\n      if (cursor) {\n        var msgObk = cursor.value;\n\n        if (msgObk.time < olderThen) {\n          ret.push(msgObk); //alert(\"Name for SSN \" + cursor.key + \" is \" + cursor.value.name);\n\n          cursor[\"continue\"]();\n        } else {\n          // no more old messages,\n          res(ret);\n          return;\n        }\n      } else {\n        res(ret);\n      }\n    };\n  });\n}\nfunction cleanOldMessages(db, ttl) {\n  return getOldMessages(db, ttl).then(function (tooOld) {\n    return Promise.all(tooOld.map(function (msgObj) {\n      return removeMessageById(db, msgObj.id);\n    }));\n  });\n}\nfunction create(channelName, options) {\n  options = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_3__options__[\"a\" /* fillOptionsWithDefaults */])(options);\n  return createDatabase(channelName).then(function (db) {\n    var state = {\n      closed: false,\n      lastCursorId: 0,\n      channelName: channelName,\n      options: options,\n      uuid: __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_1__util_js__[\"d\" /* randomToken */])(10),\n\n      /**\n       * emittedMessagesIds\n       * contains all messages that have been emitted before\n       * @type {ObliviousSet}\n       */\n      eMIs: new __WEBPACK_IMPORTED_MODULE_2__oblivious_set__[\"a\" /* default */](options.idb.ttl * 2),\n      // ensures we do not read messages in parrallel\n      writeBlockPromise: Promise.resolve(),\n      messagesCallback: null,\n      readQueuePromises: [],\n      db: db\n    };\n    /**\n     * if service-workers are used,\n     * we have no 'storage'-event if they post a message,\n     * therefore we also have to set an interval\n     */\n\n    _readLoop(state);\n\n    return state;\n  });\n}\n\nfunction _readLoop(state) {\n  if (state.closed) return;\n  return readNewMessages(state).then(function () {\n    return __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_1__util_js__[\"c\" /* sleep */])(state.options.idb.fallbackInterval);\n  }).then(function () {\n    return _readLoop(state);\n  });\n}\n\nfunction _filterMessage(msgObj, state) {\n  if (msgObj.uuid === state.uuid) return false; // send by own\n\n  if (state.eMIs.has(msgObj.id)) return false; // already emitted\n\n  if (msgObj.data.time < state.messagesCallbackTime) return false; // older then onMessageCallback\n\n  return true;\n}\n/**\n * reads all new messages from the database and emits them\n */\n\n\nfunction readNewMessages(state) {\n  // channel already closed\n  if (state.closed) return Promise.resolve(); // if no one is listening, we do not need to scan for new messages\n\n  if (!state.messagesCallback) return Promise.resolve();\n  return getMessagesHigherThen(state.db, state.lastCursorId).then(function (newerMessages) {\n    var useMessages = newerMessages.map(function (msgObj) {\n      if (msgObj.id > state.lastCursorId) {\n        state.lastCursorId = msgObj.id;\n      }\n\n      return msgObj;\n    }).filter(function (msgObj) {\n      return _filterMessage(msgObj, state);\n    }).sort(function (msgObjA, msgObjB) {\n      return msgObjA.time - msgObjB.time;\n    }); // sort by time\n\n    useMessages.forEach(function (msgObj) {\n      if (state.messagesCallback) {\n        state.eMIs.add(msgObj.id);\n        state.messagesCallback(msgObj.data);\n      }\n    });\n    return Promise.resolve();\n  });\n}\n\nfunction close(channelState) {\n  channelState.closed = true;\n  channelState.db.close();\n}\nfunction postMessage(channelState, messageJson) {\n  channelState.writeBlockPromise = channelState.writeBlockPromise.then(function () {\n    return writeMessage(channelState.db, channelState.uuid, messageJson);\n  }).then(function () {\n    if (__webpack_require__.i(__WEBPACK_IMPORTED_MODULE_1__util_js__[\"e\" /* randomInt */])(0, 10) === 0) {\n      /* await (do not await) */\n      cleanOldMessages(channelState.db, channelState.options.idb.ttl);\n    }\n  });\n  return channelState.writeBlockPromise;\n}\nfunction onMessage(channelState, fn, time) {\n  channelState.messagesCallbackTime = time;\n  channelState.messagesCallback = fn;\n  readNewMessages(channelState);\n}\nfunction canBeUsed() {\n  if (__WEBPACK_IMPORTED_MODULE_0_detect_node___default.a) return false;\n  var idb = getIdb();\n  if (!idb) return false;\n  return true;\n}\nfunction averageResponseTime(options) {\n  return options.idb.fallbackInterval * 2;\n}\n/* harmony default export */ __webpack_exports__[\"a\"] = ({\n  create: create,\n  close: close,\n  onMessage: onMessage,\n  postMessage: postMessage,\n  canBeUsed: canBeUsed,\n  type: type,\n  averageResponseTime: averageResponseTime,\n  microSeconds: microSeconds\n});\n\n/***/ }),\n/* 8 */\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\n/* unused harmony export microSeconds */\n/* unused harmony export type */\n/* unused harmony export getLocalStorage */\n/* unused harmony export storageKey */\n/* unused harmony export postMessage */\n/* unused harmony export addStorageEventListener */\n/* unused harmony export removeStorageEventListener */\n/* unused harmony export create */\n/* unused harmony export close */\n/* unused harmony export onMessage */\n/* unused harmony export canBeUsed */\n/* unused harmony export averageResponseTime */\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_detect_node__ = __webpack_require__(1);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_detect_node___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0_detect_node__);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__oblivious_set__ = __webpack_require__(3);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__options__ = __webpack_require__(2);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__util__ = __webpack_require__(0);\n/**\n * A localStorage-only method which uses localstorage and its 'storage'-event\n * This does not work inside of webworkers because they have no access to locastorage\n * This is basically implemented to support IE9 or your grandmothers toaster.\n * @link https://caniuse.com/#feat=namevalue-storage\n * @link https://caniuse.com/#feat=indexeddb\n */\n\n\n\n\nvar microSeconds = __WEBPACK_IMPORTED_MODULE_3__util__[\"b\" /* microSeconds */];\nvar KEY_PREFIX = 'pubkey.broadcastChannel-';\nvar type = 'localstorage';\n/**\n * copied from crosstab\n * @link https://github.com/tejacques/crosstab/blob/master/src/crosstab.js#L32\n */\n\nfunction getLocalStorage() {\n  var localStorage;\n  if (typeof window === 'undefined') return null;\n\n  try {\n    localStorage = window.localStorage;\n    localStorage = window['ie8-eventlistener/storage'] || window.localStorage;\n  } catch (e) {// New versions of Firefox throw a Security exception\n    // if cookies are disabled. See\n    // https://bugzilla.mozilla.org/show_bug.cgi?id=1028153\n  }\n\n  return localStorage;\n}\nfunction storageKey(channelName) {\n  return KEY_PREFIX + channelName;\n}\n/**\n* writes the new message to the storage\n* and fires the storage-event so other readers can find it\n*/\n\nfunction postMessage(channelState, messageJson) {\n  return new Promise(function (res) {\n    __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_3__util__[\"c\" /* sleep */])().then(function () {\n      var key = storageKey(channelState.channelName);\n      var writeObj = {\n        token: __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_3__util__[\"d\" /* randomToken */])(10),\n        time: new Date().getTime(),\n        data: messageJson,\n        uuid: channelState.uuid\n      };\n      var value = JSON.stringify(writeObj);\n      localStorage.setItem(key, value);\n      /**\n       * StorageEvent does not fire the 'storage' event\n       * in the window that changes the state of the local storage.\n       * So we fire it manually\n       */\n\n      var ev = document.createEvent('Event');\n      ev.initEvent('storage', true, true);\n      ev.key = key;\n      ev.newValue = value;\n      window.dispatchEvent(ev);\n      res();\n    });\n  });\n}\nfunction addStorageEventListener(channelName, fn) {\n  var key = storageKey(channelName);\n\n  var listener = function listener(ev) {\n    if (ev.key === key) {\n      fn(JSON.parse(ev.newValue));\n    }\n  };\n\n  window.addEventListener('storage', listener);\n  return listener;\n}\nfunction removeStorageEventListener(listener) {\n  window.removeEventListener('storage', listener);\n}\nfunction create(channelName, options) {\n  options = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_2__options__[\"a\" /* fillOptionsWithDefaults */])(options);\n\n  if (!canBeUsed()) {\n    throw new Error('BroadcastChannel: localstorage cannot be used');\n  }\n\n  var uuid = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_3__util__[\"d\" /* randomToken */])(10);\n  /**\n   * eMIs\n   * contains all messages that have been emitted before\n   * @type {ObliviousSet}\n   */\n\n  var eMIs = new __WEBPACK_IMPORTED_MODULE_1__oblivious_set__[\"a\" /* default */](options.localstorage.removeTimeout);\n  var state = {\n    channelName: channelName,\n    uuid: uuid,\n    eMIs: eMIs // emittedMessagesIds\n\n  };\n  state.listener = addStorageEventListener(channelName, function (msgObj) {\n    if (!state.messagesCallback) return; // no listener\n\n    if (msgObj.uuid === uuid) return; // own message\n\n    if (!msgObj.token || eMIs.has(msgObj.token)) return; // already emitted\n\n    if (msgObj.data.time && msgObj.data.time < state.messagesCallbackTime) return; // too old\n\n    eMIs.add(msgObj.token);\n    state.messagesCallback(msgObj.data);\n  });\n  return state;\n}\nfunction close(channelState) {\n  removeStorageEventListener(channelState.listener);\n}\nfunction onMessage(channelState, fn, time) {\n  channelState.messagesCallbackTime = time;\n  channelState.messagesCallback = fn;\n}\nfunction canBeUsed() {\n  if (__WEBPACK_IMPORTED_MODULE_0_detect_node___default.a) return false;\n  var ls = getLocalStorage();\n  if (!ls) return false;\n  return true;\n}\nfunction averageResponseTime() {\n  return 120;\n}\n/* harmony default export */ __webpack_exports__[\"a\"] = ({\n  create: create,\n  close: close,\n  onMessage: onMessage,\n  postMessage: postMessage,\n  canBeUsed: canBeUsed,\n  type: type,\n  averageResponseTime: averageResponseTime,\n  microSeconds: microSeconds\n});\n\n/***/ }),\n/* 9 */\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\n/* unused harmony export microSeconds */\n/* unused harmony export type */\n/* unused harmony export create */\n/* unused harmony export close */\n/* unused harmony export postMessage */\n/* unused harmony export onMessage */\n/* unused harmony export canBeUsed */\n/* unused harmony export averageResponseTime */\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_detect_node__ = __webpack_require__(1);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_detect_node___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0_detect_node__);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__util__ = __webpack_require__(0);\n\n\nvar microSeconds = __WEBPACK_IMPORTED_MODULE_1__util__[\"b\" /* microSeconds */];\nvar type = 'native';\nfunction create(channelName) {\n  var state = {\n    messagesCallback: null,\n    bc: new BroadcastChannel(channelName),\n    subFns: [] // subscriberFunctions\n\n  };\n\n  state.bc.onmessage = function (msg) {\n    if (state.messagesCallback) {\n      state.messagesCallback(msg.data);\n    }\n  };\n\n  return state;\n}\nfunction close(channelState) {\n  channelState.bc.close();\n  channelState.subFns = [];\n}\nfunction postMessage(channelState, messageJson) {\n  channelState.bc.postMessage(messageJson, false);\n}\nfunction onMessage(channelState, fn, time) {\n  channelState.messagesCallbackTime = time;\n  channelState.messagesCallback = fn;\n}\nfunction canBeUsed() {\n  /**\n   * in the electron-renderer, isNode will be true even if we are in browser-context\n   * so we also check if window is undefined\n   */\n  if (__WEBPACK_IMPORTED_MODULE_0_detect_node___default.a && typeof window === 'undefined') return false;\n\n  if (typeof BroadcastChannel === 'function') {\n    if (BroadcastChannel._pubkey) {\n      throw new Error('BroadcastChannel: Do not overwrite window.BroadcastChannel with this module, this is not a polyfill');\n    }\n\n    return true;\n  } else return false;\n}\nfunction averageResponseTime() {\n  return 100;\n}\n/* harmony default export */ __webpack_exports__[\"a\"] = ({\n  create: create,\n  close: close,\n  onMessage: onMessage,\n  postMessage: postMessage,\n  canBeUsed: canBeUsed,\n  type: type,\n  averageResponseTime: averageResponseTime,\n  microSeconds: microSeconds\n});\n\n/***/ }),\n/* 10 */\n/***/ (function(module, exports) {\n\n/* (ignored) */\n\n/***/ })\n/******/ ]);\n});\n\n\n// WEBPACK FOOTER //\n// syncState.umd.min.js"," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// identity function for calling harmony imports with the correct context\n \t__webpack_require__.i = function(value) { return value; };\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, {\n \t\t\t\tconfigurable: false,\n \t\t\t\tenumerable: true,\n \t\t\t\tget: getter\n \t\t\t});\n \t\t}\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 5);\n\n\n\n// WEBPACK FOOTER //\n// webpack/bootstrap a5d96e30fa2982463e10","/**\n * returns true if the given object is a promise\n */\nexport function isPromise(obj) {\n  if (obj && typeof obj.then === 'function') {\n    return true;\n  } else {\n    return false;\n  }\n}\nexport function sleep(time) {\n  if (!time) time = 0;\n  return new Promise(function (res) {\n    return setTimeout(res, time);\n  });\n}\nexport function randomInt(min, max) {\n  return Math.floor(Math.random() * (max - min + 1) + min);\n}\n/**\n * https://stackoverflow.com/a/1349426/3443137\n */\n\nexport function randomToken(length) {\n  if (!length) length = 5;\n  var text = '';\n  var possible = 'abcdefghijklmnopqrstuvwxzy0123456789';\n\n  for (var i = 0; i < length; i++) {\n    text += possible.charAt(Math.floor(Math.random() * possible.length));\n  }\n\n  return text;\n}\nvar lastMs = 0;\nvar additional = 0;\n/**\n * returns the current time in micro-seconds,\n * WARNING: This is a pseudo-function\n * Performance.now is not reliable in webworkers, so we just make sure to never return the same time.\n * This is enough in browsers, and this function will not be used in nodejs.\n * The main reason for this hack is to ensure that BroadcastChannel behaves equal to production when it is used in fast-running unit tests.\n */\n\nexport function microSeconds() {\n  var ms = new Date().getTime();\n\n  if (ms === lastMs) {\n    additional++;\n    return ms * 1000 + additional;\n  } else {\n    lastMs = ms;\n    additional = 0;\n    return ms * 1000;\n  }\n}\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/broadcast-channel/dist/es/util.js\n// module id = 0\n// module chunks = 0","module.exports = false;\n\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/detect-node/browser.js\n// module id = 1\n// module chunks = 0","export function fillOptionsWithDefaults(options) {\n  if (!options) options = {};\n  options = JSON.parse(JSON.stringify(options)); // main\n\n  if (typeof options.webWorkerSupport === 'undefined') options.webWorkerSupport = true; // indexed-db\n\n  if (!options.idb) options.idb = {}; //  after this time the messages get deleted\n\n  if (!options.idb.ttl) options.idb.ttl = 1000 * 45;\n  if (!options.idb.fallbackInterval) options.idb.fallbackInterval = 150; // localstorage\n\n  if (!options.localstorage) options.localstorage = {};\n  if (!options.localstorage.removeTimeout) options.localstorage.removeTimeout = 1000 * 60; // node\n\n  if (!options.node) options.node = {};\n  if (!options.node.ttl) options.node.ttl = 1000 * 60 * 2; // 2 minutes;\n\n  if (typeof options.node.useFastPath === 'undefined') options.node.useFastPath = true;\n  return options;\n}\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/broadcast-channel/dist/es/options.js\n// module id = 2\n// module chunks = 0","/**\n *\n *\n */\nvar ObliviousSet = function ObliviousSet(ttl) {\n  this.ttl = ttl;\n  this.set = new Set();\n  this.timeMap = new Map();\n  this.has = this.set.has.bind(this.set);\n};\n\nObliviousSet.prototype = {\n  add: function add(value) {\n    this.timeMap.set(value, now());\n    this.set.add(value);\n\n    _removeTooOldValues(this);\n  },\n  clear: function clear() {\n    this.set.clear();\n    this.timeMap.clear();\n  }\n};\nexport function _removeTooOldValues(obliviousSet) {\n  var olderThen = now() - obliviousSet.ttl;\n  var iterator = obliviousSet.set[Symbol.iterator]();\n\n  while (true) {\n    var value = iterator.next().value;\n    if (!value) return; // no more elements\n\n    var time = obliviousSet.timeMap.get(value);\n\n    if (time < olderThen) {\n      obliviousSet.timeMap[\"delete\"](value);\n      obliviousSet.set[\"delete\"](value);\n    } else {\n      // we reached a value that is not old enough\n      return;\n    }\n  }\n}\n\nfunction now() {\n  return new Date().getTime();\n}\n\nexport default ObliviousSet;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/broadcast-channel/dist/es/oblivious-set.js\n// module id = 3\n// module chunks = 0","import { isPromise } from './util.js';\nimport { chooseMethod } from './method-chooser.js';\nimport { fillOptionsWithDefaults } from './options.js';\n\nvar BroadcastChannel = function BroadcastChannel(name, options) {\n  this.name = name;\n  this.options = fillOptionsWithDefaults(options);\n  this.method = chooseMethod(this.options); // isListening\n\n  this._iL = false;\n  /**\n   * _onMessageListener\n   * setting onmessage twice,\n   * will overwrite the first listener\n   */\n\n  this._onML = null;\n  /**\n   * _addEventListeners\n   */\n\n  this._addEL = {\n    message: [],\n    internal: []\n  };\n  /**\n   * _beforeClose\n   * array of promises that will be awaited\n   * before the channel is closed\n   */\n\n  this._befC = [];\n  /**\n   * _preparePromise\n   */\n\n  this._prepP = null;\n\n  _prepareChannel(this);\n}; // STATICS\n\n/**\n * used to identify if someone overwrites\n * window.BroadcastChannel with this\n * See methods/native.js\n */\n\n\nBroadcastChannel._pubkey = true;\n/**\n * clears the tmp-folder if is node\n * @return {Promise<boolean>} true if has run, false if not node\n */\n\nBroadcastChannel.clearNodeFolder = function (options) {\n  options = fillOptionsWithDefaults(options);\n  var method = chooseMethod(options);\n\n  if (method.type === 'node') {\n    return method.clearNodeFolder().then(function () {\n      return true;\n    });\n  } else {\n    return Promise.resolve(false);\n  }\n}; // PROTOTYPE\n\n\nBroadcastChannel.prototype = {\n  postMessage: function postMessage(msg) {\n    if (this.closed) {\n      throw new Error('BroadcastChannel.postMessage(): ' + 'Cannot post message after channel has closed');\n    }\n\n    return _post(this, 'message', msg);\n  },\n  postInternal: function postInternal(msg) {\n    return _post(this, 'internal', msg);\n  },\n\n  set onmessage(fn) {\n    var time = this.method.microSeconds();\n    var listenObj = {\n      time: time,\n      fn: fn\n    };\n\n    _removeListenerObject(this, 'message', this._onML);\n\n    if (fn && typeof fn === 'function') {\n      this._onML = listenObj;\n\n      _addListenerObject(this, 'message', listenObj);\n    } else {\n      this._onML = null;\n    }\n  },\n\n  addEventListener: function addEventListener(type, fn) {\n    var time = this.method.microSeconds();\n    var listenObj = {\n      time: time,\n      fn: fn\n    };\n\n    _addListenerObject(this, type, listenObj);\n  },\n  removeEventListener: function removeEventListener(type, fn) {\n    var obj = this._addEL[type].find(function (obj) {\n      return obj.fn === fn;\n    });\n\n    _removeListenerObject(this, type, obj);\n  },\n  close: function close() {\n    var _this = this;\n\n    if (this.closed) return;\n    this.closed = true;\n    var awaitPrepare = this._prepP ? this._prepP : Promise.resolve();\n    this._onML = null;\n    this._addEL.message = [];\n    return awaitPrepare.then(function () {\n      return Promise.all(_this._befC.map(function (fn) {\n        return fn();\n      }));\n    }).then(function () {\n      return _this.method.close(_this._state);\n    });\n  },\n\n  get type() {\n    return this.method.type;\n  }\n\n};\n\nfunction _post(broadcastChannel, type, msg) {\n  var time = broadcastChannel.method.microSeconds();\n  var msgObj = {\n    time: time,\n    type: type,\n    data: msg\n  };\n  var awaitPrepare = broadcastChannel._prepP ? broadcastChannel._prepP : Promise.resolve();\n  return awaitPrepare.then(function () {\n    return broadcastChannel.method.postMessage(broadcastChannel._state, msgObj);\n  });\n}\n\nfunction _prepareChannel(channel) {\n  var maybePromise = channel.method.create(channel.name, channel.options);\n\n  if (isPromise(maybePromise)) {\n    channel._prepP = maybePromise;\n    maybePromise.then(function (s) {\n      // used in tests to simulate slow runtime\n\n      /*if (channel.options.prepareDelay) {\n           await new Promise(res => setTimeout(res, this.options.prepareDelay));\n      }*/\n      channel._state = s;\n    });\n  } else {\n    channel._state = maybePromise;\n  }\n}\n\nfunction _hasMessageListeners(channel) {\n  if (channel._addEL.message.length > 0) return true;\n  if (channel._addEL.internal.length > 0) return true;\n  return false;\n}\n\nfunction _addListenerObject(channel, type, obj) {\n  channel._addEL[type].push(obj);\n\n  _startListening(channel);\n}\n\nfunction _removeListenerObject(channel, type, obj) {\n  channel._addEL[type] = channel._addEL[type].filter(function (o) {\n    return o !== obj;\n  });\n\n  _stopListening(channel);\n}\n\nfunction _startListening(channel) {\n  if (!channel._iL && _hasMessageListeners(channel)) {\n    // someone is listening, start subscribing\n    var listenerFn = function listenerFn(msgObj) {\n      channel._addEL[msgObj.type].forEach(function (obj) {\n        if (msgObj.time >= obj.time) {\n          obj.fn(msgObj.data);\n        }\n      });\n    };\n\n    var time = channel.method.microSeconds();\n\n    if (channel._prepP) {\n      channel._prepP.then(function () {\n        channel._iL = true;\n        channel.method.onMessage(channel._state, listenerFn, time);\n      });\n    } else {\n      channel._iL = true;\n      channel.method.onMessage(channel._state, listenerFn, time);\n    }\n  }\n}\n\nfunction _stopListening(channel) {\n  if (channel._iL && !_hasMessageListeners(channel)) {\n    // noone is listening, stop subscribing\n    channel._iL = false;\n    var time = channel.method.microSeconds();\n    channel.method.onMessage(channel._state, null, time);\n  }\n}\n\nexport default BroadcastChannel;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/broadcast-channel/dist/es/index.js\n// module id = 4\n// module chunks = 0","/* eslint-env browser */\nimport BroadcastChannel from 'broadcast-channel';\n\nlet lastUuid = 0;\nconst GET_INIT_STATE = '&_GET_INIT_STATE';\nconst SEND_INIT_STATE = '&_SEND_INIT_STATE';\nconst RECEIVE_INIT_STATE = '&_RECEIVE_INIT_STATE';\n\nconst defaultConfig = {\n  channel: 'redux_state_sync',\n  predicate: null,\n  blacklist: [],\n  whitelist: [],\n  broadcastChannelOption: null,\n  prepareState: state => state\n};\n\nconst getIniteState = () => ({ type: GET_INIT_STATE });\nconst sendIniteState = () => ({ type: SEND_INIT_STATE });\nconst receiveIniteState = state => ({ type: RECEIVE_INIT_STATE, payload: state });\n\nfunction s4() {\n  return Math.floor((1 + Math.random()) * 0x10000)\n    .toString(16)\n    .substring(1);\n}\n\nfunction guid() {\n  return (\n    `${s4()}${s4()}-${s4()}-${s4()}-${s4()}-${s4()}${s4()}${s4()}`\n  );\n}\n\n// generate current window unique id\nconst WINDOW_STATE_SYNC_ID = guid();\n// if the message receiver is already created\nlet isMessageListenerCreated = false;\n// export for test\nexport function generateUuidForAction(action) {\n  const stampedAction = action;\n  stampedAction.$uuid = guid();\n  stampedAction.$wuid = WINDOW_STATE_SYNC_ID;\n  return stampedAction;\n}\n// export for test\nexport function isActionAllowed({ predicate, blacklist, whitelist }) {\n  let allowed = () => true;\n\n  if (predicate && typeof predicate === 'function') {\n    allowed = predicate;\n  } else if (Array.isArray(blacklist)) {\n    allowed = type => blacklist.indexOf(type) < 0;\n  } else if (Array.isArray(whitelist)) {\n    allowed = type => whitelist.indexOf(type) >= 0;\n  }\n  return allowed;\n}\n// export for test\nexport function isActionSynced(action) {\n  return !!action.$isSync;\n}\n// export for test\nexport function createMessageListener({ channel, dispatch, allowed }) {\n  let isSynced = false;\n  const tabs = {};\n  const messageChannel = channel;\n  messageChannel.onmessage = (stampedAction) => {\n    // Ignore if this action is triggered by this window\n    if (stampedAction.$wuid === WINDOW_STATE_SYNC_ID) {\n      return;\n    }\n    // IE bug https://stackoverflow.com/questions/18265556/why-does-internet-explorer-fire-the-window-storage-event-on-the-window-that-st\n    if (stampedAction.type === RECEIVE_INIT_STATE) {\n      return;\n    }\n    // ignore other values that saved to localstorage.\n    if (stampedAction.$uuid && stampedAction.$uuid !== lastUuid) {\n      if (stampedAction.type === GET_INIT_STATE && !tabs[stampedAction.$wuid]) {\n        tabs[stampedAction.$wuid] = true;\n        dispatch(sendIniteState());\n      } else if (stampedAction.type === SEND_INIT_STATE && !tabs[stampedAction.$wuid]) {\n        if (!isSynced) {\n          isSynced = true;\n          dispatch(receiveIniteState(stampedAction.payload));\n        }\n        return;\n      } else if (allowed(stampedAction.type)) {\n        lastUuid = stampedAction.$uuid;\n        dispatch(Object.assign(stampedAction, {\n          $isSync: true,\n        }));\n      }\n    }\n  };\n}\n\nexport const createStateSyncMiddleware = (config = defaultConfig) => {\n  const allowed = isActionAllowed(config);\n  const channel = new BroadcastChannel(config.channel, config.broadcastChannelOption);\n  const prepareState = config.prepareState || defaultConfig.prepareState;\n\n  return ({ getState, dispatch }) => next => (action) => {\n    // create message receiver\n    if (!isMessageListenerCreated) {\n      isMessageListenerCreated = true;\n      createMessageListener({ channel, dispatch, allowed });\n    }\n    // post messages\n    if (action && !action.$uuid) {\n      const stampedAction = generateUuidForAction(action);\n      lastUuid = stampedAction.$uuid;\n      try {\n        if (action.type === SEND_INIT_STATE) {\n          if (getState()) {\n            stampedAction.payload = prepareState(getState());\n            channel.postMessage(stampedAction);\n          }\n          return next(action);\n        }\n        if (allowed(stampedAction.type) || action.type === GET_INIT_STATE) {\n          channel.postMessage(stampedAction);\n        }\n      } catch (e) {\n        console.error(\"Your browser doesn't support cross tab communication\");\n      }\n    }\n    return next(Object.assign(action, {\n      $isSync: typeof action.$isSync === 'undefined' ? false : action.$isSync,\n    }));\n  };\n};\n\nexport const createReduxStateSync = ({ prepareState }) => appReducer =>\n  ((state, action) => {\n    let initState = state;\n    if (action.type === RECEIVE_INIT_STATE) {\n      initState = prepareState(action.payload);\n    }\n    return appReducer(initState, action);\n  });\n\n// init state with other tab's state\nexport const withReduxStateSync = createReduxStateSync({\n  prepareState: state => state\n})\n\nexport const initStateWithPrevTab = ({ dispatch }) => {\n  dispatch(getIniteState());\n};\n\n\n\n// WEBPACK FOOTER //\n// ./src/syncState.js","import isNode from 'detect-node';\nimport NativeMethod from './methods/native.js';\nimport IndexeDbMethod from './methods/indexed-db.js';\nimport LocalstorageMethod from './methods/localstorage.js'; // order is important\n\nvar METHODS = [NativeMethod, // fastest\nIndexeDbMethod, LocalstorageMethod];\nvar REQUIRE_FUN = require;\n/**\n * The NodeMethod is loaded lazy\n * so it will not get bundled in browser-builds\n */\n\nif (isNode) {\n  /**\n   * we use the non-transpiled code for nodejs\n   * because it runs faster\n   */\n  var NodeMethod = REQUIRE_FUN('../../src/methods/node.js');\n  /**\n   * this will be false for webpackbuilds\n   * which will shim the node-method with an empty object {}\n   */\n\n  if (typeof NodeMethod.canBeUsed === 'function') {\n    METHODS.push(NodeMethod);\n  }\n}\n\nexport function chooseMethod(options) {\n  // directly chosen\n  if (options.type) {\n    var ret = METHODS.find(function (m) {\n      return m.type === options.type;\n    });\n    if (!ret) throw new Error('method-type ' + options.type + ' not found');else return ret;\n  }\n\n  var chooseMethods = METHODS;\n\n  if (!options.webWorkerSupport && !isNode) {\n    // prefer localstorage over idb when no webworker-support needed\n    chooseMethods = METHODS.filter(function (m) {\n      return m.type !== 'idb';\n    });\n  }\n\n  var useMethod = chooseMethods.find(function (method) {\n    return method.canBeUsed();\n  });\n  if (!useMethod) throw new Error('No useable methode found:' + JSON.stringify(METHODS.map(function (m) {\n    return m.type;\n  })));else return useMethod;\n}\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/broadcast-channel/dist/es/method-chooser.js\n// module id = 6\n// module chunks = 0","/**\n * this method uses indexeddb to store the messages\n * There is currently no observerAPI for idb\n * @link https://github.com/w3c/IndexedDB/issues/51\n */\nimport isNode from 'detect-node';\nimport { sleep, randomInt, randomToken, microSeconds as micro } from '../util.js';\nexport var microSeconds = micro;\nimport ObliviousSet from '../oblivious-set';\nimport { fillOptionsWithDefaults } from '../options';\nvar DB_PREFIX = 'pubkey.broadcast-channel-0-';\nvar OBJECT_STORE_ID = 'messages';\nexport var type = 'idb';\nexport function getIdb() {\n  if (typeof indexedDB !== 'undefined') return indexedDB;\n  if (typeof window.mozIndexedDB !== 'undefined') return window.mozIndexedDB;\n  if (typeof window.webkitIndexedDB !== 'undefined') return window.webkitIndexedDB;\n  if (typeof window.msIndexedDB !== 'undefined') return window.msIndexedDB;\n  return false;\n}\nexport function createDatabase(channelName) {\n  var IndexedDB = getIdb(); // create table\n\n  var dbName = DB_PREFIX + channelName;\n  var openRequest = IndexedDB.open(dbName, 1);\n\n  openRequest.onupgradeneeded = function (ev) {\n    var db = ev.target.result;\n    db.createObjectStore(OBJECT_STORE_ID, {\n      keyPath: 'id',\n      autoIncrement: true\n    });\n  };\n\n  var dbPromise = new Promise(function (res, rej) {\n    openRequest.onerror = function (ev) {\n      return rej(ev);\n    };\n\n    openRequest.onsuccess = function () {\n      res(openRequest.result);\n    };\n  });\n  return dbPromise;\n}\n/**\n * writes the new message to the database\n * so other readers can find it\n */\n\nexport function writeMessage(db, readerUuid, messageJson) {\n  var time = new Date().getTime();\n  var writeObject = {\n    uuid: readerUuid,\n    time: time,\n    data: messageJson\n  };\n  var transaction = db.transaction([OBJECT_STORE_ID], 'readwrite');\n  return new Promise(function (res, rej) {\n    transaction.oncomplete = function () {\n      return res();\n    };\n\n    transaction.onerror = function (ev) {\n      return rej(ev);\n    };\n\n    var objectStore = transaction.objectStore(OBJECT_STORE_ID);\n    objectStore.add(writeObject);\n  });\n}\nexport function getAllMessages(db) {\n  var objectStore = db.transaction(OBJECT_STORE_ID).objectStore(OBJECT_STORE_ID);\n  var ret = [];\n  return new Promise(function (res) {\n    objectStore.openCursor().onsuccess = function (ev) {\n      var cursor = ev.target.result;\n\n      if (cursor) {\n        ret.push(cursor.value); //alert(\"Name for SSN \" + cursor.key + \" is \" + cursor.value.name);\n\n        cursor[\"continue\"]();\n      } else {\n        res(ret);\n      }\n    };\n  });\n}\nexport function getMessagesHigherThen(db, lastCursorId) {\n  var objectStore = db.transaction(OBJECT_STORE_ID).objectStore(OBJECT_STORE_ID);\n  var ret = [];\n  var keyRangeValue = IDBKeyRange.bound(lastCursorId + 1, Infinity);\n  return new Promise(function (res) {\n    objectStore.openCursor(keyRangeValue).onsuccess = function (ev) {\n      var cursor = ev.target.result;\n\n      if (cursor) {\n        ret.push(cursor.value); //alert(\"Name for SSN \" + cursor.key + \" is \" + cursor.value.name);\n\n        cursor[\"continue\"]();\n      } else {\n        res(ret);\n      }\n    };\n  });\n}\nexport function removeMessageById(db, id) {\n  var request = db.transaction([OBJECT_STORE_ID], 'readwrite').objectStore(OBJECT_STORE_ID)[\"delete\"](id);\n  return new Promise(function (res) {\n    request.onsuccess = function () {\n      return res();\n    };\n  });\n}\nexport function getOldMessages(db, ttl) {\n  var olderThen = new Date().getTime() - ttl;\n  var objectStore = db.transaction(OBJECT_STORE_ID).objectStore(OBJECT_STORE_ID);\n  var ret = [];\n  return new Promise(function (res) {\n    objectStore.openCursor().onsuccess = function (ev) {\n      var cursor = ev.target.result;\n\n      if (cursor) {\n        var msgObk = cursor.value;\n\n        if (msgObk.time < olderThen) {\n          ret.push(msgObk); //alert(\"Name for SSN \" + cursor.key + \" is \" + cursor.value.name);\n\n          cursor[\"continue\"]();\n        } else {\n          // no more old messages,\n          res(ret);\n          return;\n        }\n      } else {\n        res(ret);\n      }\n    };\n  });\n}\nexport function cleanOldMessages(db, ttl) {\n  return getOldMessages(db, ttl).then(function (tooOld) {\n    return Promise.all(tooOld.map(function (msgObj) {\n      return removeMessageById(db, msgObj.id);\n    }));\n  });\n}\nexport function create(channelName, options) {\n  options = fillOptionsWithDefaults(options);\n  return createDatabase(channelName).then(function (db) {\n    var state = {\n      closed: false,\n      lastCursorId: 0,\n      channelName: channelName,\n      options: options,\n      uuid: randomToken(10),\n\n      /**\n       * emittedMessagesIds\n       * contains all messages that have been emitted before\n       * @type {ObliviousSet}\n       */\n      eMIs: new ObliviousSet(options.idb.ttl * 2),\n      // ensures we do not read messages in parrallel\n      writeBlockPromise: Promise.resolve(),\n      messagesCallback: null,\n      readQueuePromises: [],\n      db: db\n    };\n    /**\n     * if service-workers are used,\n     * we have no 'storage'-event if they post a message,\n     * therefore we also have to set an interval\n     */\n\n    _readLoop(state);\n\n    return state;\n  });\n}\n\nfunction _readLoop(state) {\n  if (state.closed) return;\n  return readNewMessages(state).then(function () {\n    return sleep(state.options.idb.fallbackInterval);\n  }).then(function () {\n    return _readLoop(state);\n  });\n}\n\nfunction _filterMessage(msgObj, state) {\n  if (msgObj.uuid === state.uuid) return false; // send by own\n\n  if (state.eMIs.has(msgObj.id)) return false; // already emitted\n\n  if (msgObj.data.time < state.messagesCallbackTime) return false; // older then onMessageCallback\n\n  return true;\n}\n/**\n * reads all new messages from the database and emits them\n */\n\n\nfunction readNewMessages(state) {\n  // channel already closed\n  if (state.closed) return Promise.resolve(); // if no one is listening, we do not need to scan for new messages\n\n  if (!state.messagesCallback) return Promise.resolve();\n  return getMessagesHigherThen(state.db, state.lastCursorId).then(function (newerMessages) {\n    var useMessages = newerMessages.map(function (msgObj) {\n      if (msgObj.id > state.lastCursorId) {\n        state.lastCursorId = msgObj.id;\n      }\n\n      return msgObj;\n    }).filter(function (msgObj) {\n      return _filterMessage(msgObj, state);\n    }).sort(function (msgObjA, msgObjB) {\n      return msgObjA.time - msgObjB.time;\n    }); // sort by time\n\n    useMessages.forEach(function (msgObj) {\n      if (state.messagesCallback) {\n        state.eMIs.add(msgObj.id);\n        state.messagesCallback(msgObj.data);\n      }\n    });\n    return Promise.resolve();\n  });\n}\n\nexport function close(channelState) {\n  channelState.closed = true;\n  channelState.db.close();\n}\nexport function postMessage(channelState, messageJson) {\n  channelState.writeBlockPromise = channelState.writeBlockPromise.then(function () {\n    return writeMessage(channelState.db, channelState.uuid, messageJson);\n  }).then(function () {\n    if (randomInt(0, 10) === 0) {\n      /* await (do not await) */\n      cleanOldMessages(channelState.db, channelState.options.idb.ttl);\n    }\n  });\n  return channelState.writeBlockPromise;\n}\nexport function onMessage(channelState, fn, time) {\n  channelState.messagesCallbackTime = time;\n  channelState.messagesCallback = fn;\n  readNewMessages(channelState);\n}\nexport function canBeUsed() {\n  if (isNode) return false;\n  var idb = getIdb();\n  if (!idb) return false;\n  return true;\n}\nexport function averageResponseTime(options) {\n  return options.idb.fallbackInterval * 2;\n}\nexport default {\n  create: create,\n  close: close,\n  onMessage: onMessage,\n  postMessage: postMessage,\n  canBeUsed: canBeUsed,\n  type: type,\n  averageResponseTime: averageResponseTime,\n  microSeconds: microSeconds\n};\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/broadcast-channel/dist/es/methods/indexed-db.js\n// module id = 7\n// module chunks = 0","/**\n * A localStorage-only method which uses localstorage and its 'storage'-event\n * This does not work inside of webworkers because they have no access to locastorage\n * This is basically implemented to support IE9 or your grandmothers toaster.\n * @link https://caniuse.com/#feat=namevalue-storage\n * @link https://caniuse.com/#feat=indexeddb\n */\nimport isNode from 'detect-node';\nimport ObliviousSet from '../oblivious-set';\nimport { fillOptionsWithDefaults } from '../options';\nimport { sleep, randomToken, microSeconds as micro } from '../util';\nexport var microSeconds = micro;\nvar KEY_PREFIX = 'pubkey.broadcastChannel-';\nexport var type = 'localstorage';\n/**\n * copied from crosstab\n * @link https://github.com/tejacques/crosstab/blob/master/src/crosstab.js#L32\n */\n\nexport function getLocalStorage() {\n  var localStorage;\n  if (typeof window === 'undefined') return null;\n\n  try {\n    localStorage = window.localStorage;\n    localStorage = window['ie8-eventlistener/storage'] || window.localStorage;\n  } catch (e) {// New versions of Firefox throw a Security exception\n    // if cookies are disabled. See\n    // https://bugzilla.mozilla.org/show_bug.cgi?id=1028153\n  }\n\n  return localStorage;\n}\nexport function storageKey(channelName) {\n  return KEY_PREFIX + channelName;\n}\n/**\n* writes the new message to the storage\n* and fires the storage-event so other readers can find it\n*/\n\nexport function postMessage(channelState, messageJson) {\n  return new Promise(function (res) {\n    sleep().then(function () {\n      var key = storageKey(channelState.channelName);\n      var writeObj = {\n        token: randomToken(10),\n        time: new Date().getTime(),\n        data: messageJson,\n        uuid: channelState.uuid\n      };\n      var value = JSON.stringify(writeObj);\n      localStorage.setItem(key, value);\n      /**\n       * StorageEvent does not fire the 'storage' event\n       * in the window that changes the state of the local storage.\n       * So we fire it manually\n       */\n\n      var ev = document.createEvent('Event');\n      ev.initEvent('storage', true, true);\n      ev.key = key;\n      ev.newValue = value;\n      window.dispatchEvent(ev);\n      res();\n    });\n  });\n}\nexport function addStorageEventListener(channelName, fn) {\n  var key = storageKey(channelName);\n\n  var listener = function listener(ev) {\n    if (ev.key === key) {\n      fn(JSON.parse(ev.newValue));\n    }\n  };\n\n  window.addEventListener('storage', listener);\n  return listener;\n}\nexport function removeStorageEventListener(listener) {\n  window.removeEventListener('storage', listener);\n}\nexport function create(channelName, options) {\n  options = fillOptionsWithDefaults(options);\n\n  if (!canBeUsed()) {\n    throw new Error('BroadcastChannel: localstorage cannot be used');\n  }\n\n  var uuid = randomToken(10);\n  /**\n   * eMIs\n   * contains all messages that have been emitted before\n   * @type {ObliviousSet}\n   */\n\n  var eMIs = new ObliviousSet(options.localstorage.removeTimeout);\n  var state = {\n    channelName: channelName,\n    uuid: uuid,\n    eMIs: eMIs // emittedMessagesIds\n\n  };\n  state.listener = addStorageEventListener(channelName, function (msgObj) {\n    if (!state.messagesCallback) return; // no listener\n\n    if (msgObj.uuid === uuid) return; // own message\n\n    if (!msgObj.token || eMIs.has(msgObj.token)) return; // already emitted\n\n    if (msgObj.data.time && msgObj.data.time < state.messagesCallbackTime) return; // too old\n\n    eMIs.add(msgObj.token);\n    state.messagesCallback(msgObj.data);\n  });\n  return state;\n}\nexport function close(channelState) {\n  removeStorageEventListener(channelState.listener);\n}\nexport function onMessage(channelState, fn, time) {\n  channelState.messagesCallbackTime = time;\n  channelState.messagesCallback = fn;\n}\nexport function canBeUsed() {\n  if (isNode) return false;\n  var ls = getLocalStorage();\n  if (!ls) return false;\n  return true;\n}\nexport function averageResponseTime() {\n  return 120;\n}\nexport default {\n  create: create,\n  close: close,\n  onMessage: onMessage,\n  postMessage: postMessage,\n  canBeUsed: canBeUsed,\n  type: type,\n  averageResponseTime: averageResponseTime,\n  microSeconds: microSeconds\n};\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/broadcast-channel/dist/es/methods/localstorage.js\n// module id = 8\n// module chunks = 0","import isNode from 'detect-node';\nimport { microSeconds as micro } from '../util';\nexport var microSeconds = micro;\nexport var type = 'native';\nexport function create(channelName) {\n  var state = {\n    messagesCallback: null,\n    bc: new BroadcastChannel(channelName),\n    subFns: [] // subscriberFunctions\n\n  };\n\n  state.bc.onmessage = function (msg) {\n    if (state.messagesCallback) {\n      state.messagesCallback(msg.data);\n    }\n  };\n\n  return state;\n}\nexport function close(channelState) {\n  channelState.bc.close();\n  channelState.subFns = [];\n}\nexport function postMessage(channelState, messageJson) {\n  channelState.bc.postMessage(messageJson, false);\n}\nexport function onMessage(channelState, fn, time) {\n  channelState.messagesCallbackTime = time;\n  channelState.messagesCallback = fn;\n}\nexport function canBeUsed() {\n  /**\n   * in the electron-renderer, isNode will be true even if we are in browser-context\n   * so we also check if window is undefined\n   */\n  if (isNode && typeof window === 'undefined') return false;\n\n  if (typeof BroadcastChannel === 'function') {\n    if (BroadcastChannel._pubkey) {\n      throw new Error('BroadcastChannel: Do not overwrite window.BroadcastChannel with this module, this is not a polyfill');\n    }\n\n    return true;\n  } else return false;\n}\nexport function averageResponseTime() {\n  return 100;\n}\nexport default {\n  create: create,\n  close: close,\n  onMessage: onMessage,\n  postMessage: postMessage,\n  canBeUsed: canBeUsed,\n  type: type,\n  averageResponseTime: averageResponseTime,\n  microSeconds: microSeconds\n};\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/broadcast-channel/dist/es/methods/native.js\n// module id = 9\n// module chunks = 0"],"sourceRoot":""}
